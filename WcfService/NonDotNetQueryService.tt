<#
/*
	Generates a service class for queries to be consumed by non-.NET clients.
*/
#>
<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ output extension=".cs" #>
<#
	// To debug, uncomment the next two lines !! 
	// System.Diagnostics.Debugger.Launch();
	// System.Diagnostics.Debugger.Break();

	Initialize(this);

	var queryTypes = GetAllQueryTypes(ContractProject).ToArray(); 

	var referencedNamespaces = GetAllReferencedNamespaces(queryTypes);

#>
// <auto-generated />
#pragma warning disable 1591
namespace WcfService
{
    using System.ServiceModel;

    using Contract;
<#  foreach (var referencedNamespace in referencedNamespaces) { #>
    using <#=referencedNamespace #>;
<#} #>

    [ServiceContract(Namespace = "http://www.cuttingedge.it/solid/queryservice/v1.0")]
    public class NonDotNetQueryService
    {
<#
	    foreach (var queryType in queryTypes)
		{
			var @interface = GetQueryInterfaceForCodeClass(queryType);
			var resultType = GetQueryResultType(@interface);

#>        [OperationContract]
		[FaultContract(typeof(ValidationError))]
        public <#= resultType #> <#= queryType.Name.Replace("Query", "") #>(<#= queryType.Name #> query) => Execute(query);
			     
<#      } #>
		private static TResult Execute<TResult>(IQuery<TResult> query) => (TResult)QueryService.ExecuteQuery(query);
	}
}
<#+ 
const string QueryInterface = "IQuery";

static DTE Dte;
static Project CurrentProject;
static Project ContractProject;
static TextTransformation TT;
static string T4FileName;
static string T4Folder;
// static string GeneratedCode = @"GeneratedCode(""SolidServices"", ""1.0"")";
static Microsoft.CSharp.CSharpCodeProvider codeProvider = new Microsoft.CSharp.CSharpCodeProvider();


void Initialize(TextTransformation tt) {
    TT = tt;
    T4FileName = Path.GetFileName(Host.TemplateFile);
    T4Folder = Path.GetDirectoryName(Host.TemplateFile);

    // Get the DTE service from the host
    var serviceProvider = Host as IServiceProvider;
    if (serviceProvider != null) {
        Dte = serviceProvider.GetService(typeof(SDTE)) as DTE;
    }

    // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
    if (Dte == null) {
        throw new Exception("This template can only be executed through the Visual Studio host");
    }

    CurrentProject = GetProjectContainingT4File(Dte);
	ContractProject = GetContractProject(Dte);

}

Project GetProjectContainingT4File(DTE dte) {

    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
        projectItem.Open(Constants.vsViewKindCode);

    // Mark the .tt file as unsaved. This way it will be saved and update itself next time the
    // project is built. Basically, it keeps marking itself as unsaved to make the next build work.
    // Note: this is certainly hacky, but is the best I could come up with so far.
    projectItem.Document.Saved = false;

    return projectItem.ContainingProject;
}

Project GetContractProject(DTE dte)
{
	string queryCsFile = QueryInterface + ".cs";

    ProjectItem projectItem = dte.Solution.FindProjectItem(queryCsFile);

    if (projectItem == null) {
        Error("Could not find the VS Project containing the " + queryCsFile + " file.");
        return null;
    }

    return projectItem.ContainingProject;
}

IEnumerable<CodeClass2> GetAllQueryTypes(params Project[] projects)
{
	return
		from Project project in projects
		from ProjectItem projectItem in project.ProjectItems
		from type in GetAllQueryTypesRecursive(projectItem)
		select type;
}


IEnumerable<CodeClass2> GetAllQueryTypesRecursive(ProjectItem projectItem)
{
	var queryTypes = GetAllQueryTypes(projectItem);

	var recursiveQueryTypes = 
		from ProjectItem subItem in projectItem.ProjectItems
		from type in GetAllQueryTypesRecursive(subItem)
		select type;

	return queryTypes.Union(recursiveQueryTypes);
}

IEnumerable<CodeClass2> GetAllQueryTypes(ProjectItem projectItem)
{	
	if (projectItem.FileCodeModel == null)
    {
		return Enumerable.Empty<CodeClass2>();
    }
	
	var elements = projectItem.FileCodeModel.CodeElements.OfType<object>().ToArray();

	var namespacedTypes =
		from @namespace in projectItem.FileCodeModel.CodeElements.OfType<CodeNamespace>()
		from type in @namespace.Members.OfType<CodeClass2>()
		select type;

	var rootTypes = projectItem.FileCodeModel.CodeElements.OfType<CodeClass2>();

	return
		from type in rootTypes.Union(namespacedTypes)
		where ImplementsQueryInterface(type)
		select type;
}

private string[] GetAllReferencedNamespaces(IEnumerable<CodeClass2> queryTypes)
{
	return (
		from type in queryTypes
		orderby type.Namespace.Name
		select type.Namespace.Name)
		.Distinct()
		.ToArray();
}

private bool ImplementsQueryInterface(CodeClass2 type)
{
	return GetQueryInterfaceForCodeClass(type) != null;
}

private CodeInterface GetQueryInterfaceForCodeClass(CodeClass2 type)
{
	var queryInterfaces =
		from implementedInterface in type.ImplementedInterfaces.OfType<CodeInterface>()
		where implementedInterface.Name.StartsWith(QueryInterface)
		select implementedInterface;

	return queryInterfaces.FirstOrDefault();
}
private static readonly int iqueryTypeNameLength = "Contract.IQuery".Length;
private static string GetQueryResultType(CodeInterface queryType)
{
	return queryType.FullName.Substring(iqueryTypeNameLength + 1, queryType.FullName.Length - (iqueryTypeNameLength + 2));
}

#>